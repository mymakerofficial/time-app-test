import z from 'zod'
import { CookieSchema } from '@/model/domain/cookie.ts'
import { UserIdSchema, UsernameSchema } from '@/model/domain/user.ts'
import { hexExamples } from '@/zod.ts'
import {
  AuthenticatorTransportFutureSchema,
  PublicKeyCredentialCreationOptionsJSONSchema,
  RegistrationResponseJSONSchema,
} from '@/model/domain/passkey.ts'

export const AuthMethod = {
  Srp: 'SRP',
  Passkey: 'PASSKEY',
} as const
export type AuthMethod = (typeof AuthMethod)[keyof typeof AuthMethod]

export const AuthMethodSchema = z.enum(AuthMethod)
export const SrpSaltSchema = z.hex().meta({ examples: hexExamples() })
export const SrpVerifierSchema = z.hex().meta({ examples: hexExamples() })
export const SrpClientPublicEphemeralSchema = z
  .hex()
  .meta({ examples: hexExamples() })
export const SrpServerPublicEphemeralSchema = z
  .hex()
  .meta({ examples: hexExamples() })
export const SrpClientProofSchema = z.hex().meta({ examples: hexExamples() })
export const SrpServerProofSchema = z.hex().meta({ examples: hexExamples() })
export const JwtAccessTokenSchema = z.jwt()
export const KekSaltSchema = z.hex().meta({ examples: hexExamples() })
export const EncryptedDekSchema = z
  .hex()
  .describe('the data encryption key encrypted using the key encryption key')
  .meta({ examples: hexExamples() })

const SRP_API_META = {
  title: 'Secure Remote Password',
}
const PASSKEY_API_META = {
  title: 'Passkey',
}

// Authenticator

export const SrpUserAuthenticatorDtoSchema = z.object({
  salt: SrpSaltSchema,
  verifier: SrpVerifierSchema,
})
export const PasskeyUserAuthenticatorDtoSchema = z.object({
  id: z.base64url(),
  publicKey: z.hex(),
  counter: z.number(),
  transports: AuthenticatorTransportFutureSchema.array().optional(),
})

export const UserAuthenticatorDtoSchema = z.discriminatedUnion('method', [
  SrpUserAuthenticatorDtoSchema.extend({
    method: z.literal(AuthMethod.Srp),
  }),
  PasskeyUserAuthenticatorDtoSchema.extend({
    method: z.literal(AuthMethod.Passkey),
  }),
])
export type UserAuthenticatorDto = z.Infer<typeof UserAuthenticatorDtoSchema>

// Encryption

export const EncryptionPublicDtoSchema = z
  .object({
    kekSalt: KekSaltSchema,
    encryptedDek: EncryptedDekSchema,
  })
  .meta({
    description:
      'public data generated by the client that can only be turned into the decryption key using client private information',
  })
export type EncryptionPublicDto = z.Infer<typeof EncryptionPublicDtoSchema>

export const UserAuthenticatorWithEncryptionSchema = z.object({
  userId: UserIdSchema,
  authenticator: UserAuthenticatorDtoSchema,
  encryption: EncryptionPublicDtoSchema,
})
export type UserAuthenticatorWithEncryption = z.Infer<
  typeof UserAuthenticatorWithEncryptionSchema
>

// Registration Start

export const RegistrationStartInputSchema = z.object({
  userId: UserIdSchema,
  username: UsernameSchema,
})
export type RegistrationStartInput = z.Infer<
  typeof RegistrationStartInputSchema
>

export const PasskeyRegistrationCacheDtoSchema = z.object({
  challenge: z.base64url(),
})
export type PasskeyRegistrationCacheDto = z.Infer<
  typeof PasskeyRegistrationCacheDtoSchema
>
export const PasskeyRegistrationStartClientResponseDtoSchema = z.object({
  options: PublicKeyCredentialCreationOptionsJSONSchema,
})

export const RegistrationCacheDtoSchema = z.discriminatedUnion('method', [
  z.object({
    method: z.literal(AuthMethod.Srp),
  }),
  PasskeyRegistrationCacheDtoSchema.extend({
    method: z.literal(AuthMethod.Passkey),
  }),
])
export type RegistrationCacheDto = z.Infer<typeof RegistrationCacheDtoSchema>

export const RegistrationStartClientResponseDtoSchema = z.discriminatedUnion(
  'method',
  [
    z
      .object({
        method: z.literal(AuthMethod.Srp),
      })
      .meta(SRP_API_META),
    PasskeyRegistrationStartClientResponseDtoSchema.extend({
      method: z.literal(AuthMethod.Passkey),
    }).meta(PASSKEY_API_META),
  ],
)

export const RegistrationStartSuccessDtoSchema = z.object({
  clientData: RegistrationStartClientResponseDtoSchema,
  cacheData: RegistrationCacheDtoSchema,
})
export type RegistrationStartSuccessDto = z.Infer<
  typeof RegistrationStartSuccessDtoSchema
>

// Registration Finish

export const SrpRegistrationFinishClientRequestDtoSchema =
  SrpUserAuthenticatorDtoSchema
export const PasskeyRegistrationFinishClientRequestDtoSchema = z.object({
  response: RegistrationResponseJSONSchema,
})

export const RegistrationStartClientRequestDtoSchema = z.discriminatedUnion(
  'method',
  [
    SrpRegistrationFinishClientRequestDtoSchema.extend({
      method: z.literal(AuthMethod.Srp),
    }).meta(SRP_API_META),
    PasskeyRegistrationFinishClientRequestDtoSchema.extend({
      method: z.literal(AuthMethod.Passkey),
    }).meta(PASSKEY_API_META),
  ],
)
export type RegistrationStartClientRequestDto = z.Infer<
  typeof RegistrationStartClientRequestDtoSchema
>

export const RegistrationFinishInputSchema = z.object({
  clientData: RegistrationStartClientRequestDtoSchema,
  cacheData: RegistrationCacheDtoSchema,
})
export type RegistrationFinishInput = z.Infer<
  typeof RegistrationFinishInputSchema
>

export const RegistrationFinishSuccessDtoSchema = z.object({
  authenticatorData: UserAuthenticatorDtoSchema,
})
export type RegistrationFinishSuccessDto = z.Infer<
  typeof RegistrationFinishSuccessDtoSchema
>

/** @deprecated */
export const UserPasswordDataSchema = z.object({
  userId: UserIdSchema,
  username: UsernameSchema,
  authSalt: SrpSaltSchema,
  authVerifier: SrpVerifierSchema,
  kekSalt: KekSaltSchema,
  encryptedDek: EncryptedDekSchema,
})
/** @deprecated */
export type UserPasswordData = z.Infer<typeof UserPasswordDataSchema>

/** @deprecated */
export const CreateUserPasswordDataSchema = z.object({
  userId: UserIdSchema,
  authSalt: SrpSaltSchema,
  authVerifier: SrpVerifierSchema,
  kekSalt: KekSaltSchema,
  encryptedDek: EncryptedDekSchema,
})
/** @deprecated */
export type CreateUserPasswordData = z.Infer<
  typeof CreateUserPasswordDataSchema
>

export const PasswordLoginStartClientDataSchema = z.object({
  username: UsernameSchema,
  clientPublicEphemeral: SrpClientPublicEphemeralSchema,
})
export type PasswordLoginStartClientData = z.Infer<
  typeof PasswordLoginStartClientDataSchema
>

export const PasswordLoginStartServerDataSchema = z.object({
  userId: UserIdSchema,
  authSalt: SrpSaltSchema,
  serverPublicEphemeral: SrpServerPublicEphemeralSchema,
})
export type PasswordLoginStartServerData = z.Infer<
  typeof PasswordLoginStartServerDataSchema
>

export const PasswordLoginFinishClientDataSchema = z.object({
  userId: UserIdSchema,
  clientProof: SrpClientProofSchema,
})
export type PasswordLoginFinishClientData = z.Infer<
  typeof PasswordLoginFinishClientDataSchema
>

export const PasswordLoginFinishServerDataSchema = z.object({
  serverProof: SrpServerProofSchema,
  accessToken: JwtAccessTokenSchema,
  refreshToken: CookieSchema,
  kekSalt: KekSaltSchema,
  encryptedDek: EncryptedDekSchema,
})
export type PasswordLoginFinishServerData = z.Infer<
  typeof PasswordLoginFinishServerDataSchema
>
